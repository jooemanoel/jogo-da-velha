<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>OFX → JSON Parser Robusto</title>
<style>
  body { font-family: Arial; padding: 20px; }
  pre { background: #f3f3f3; padding: 10px; white-space: pre-wrap; }
</style>
</head>
<body>

<h1>Converter OFX para JSON</h1>
<input type="file" id="file" accept=".ofx" />
<pre id="resultado"></pre>

<script>
// ---------------------------------------------
// 1. Parser robusto linha-a-linha (SGML → XML)
// ---------------------------------------------
function ofxToXml(ofxText) {
  const lines = ofxText.split(/\r?\n/);
  let xml = "";
  let started = false;

  for (let line of lines) {
    line = line.trim();
    if (!line) continue;

    // Detecta começo real do OFX
    if (!started && line.startsWith("<OFX>")) {
      started = true;
    }
    if (!started) continue;

    // Se já é XML bem formado, só copia
    if (/^<[^>]+>.*<\/[^>]+>$/.test(line)) {
      xml += line + "\n";
      continue;
    }

    // Caso SGML sem fechamento:
    // Ex: <TAG>valor
    const match = line.match(/^<([A-Z0-9_]+)>(.+)$/i);
    if (match) {
      const tag = match[1];
      const value = match[2].trim();
      xml += `<${tag}>${value}</${tag}>\n`;
      continue;
    }

    // Mantém tags como <OFX> ou </OFX>
    if (line.startsWith("<") && line.endsWith(">")) {
      xml += line + "\n";
    }
  }

  return xml;
}

// ------------------------------------------------
// 2. XML → JSON
// ------------------------------------------------
function xmlToJson(node) {
  // Se é nó de texto: retorna só o texto (sem "#text")
  if (node.nodeType === 3) {
    const text = node.nodeValue.trim();
    return text === "" ? null : text;
  }

  // Nó de elemento
  let obj = {};
  let hasElementChildren = false;

  for (const child of node.childNodes) {
    // Texto direto dentro de um elemento: retorna string simples
    if (child.nodeType === 3) {
      const text = child.nodeValue.trim();
      if (text !== "") {
        return text; // <-- importância: retorna valor direto!
      }
      continue;
    }

    hasElementChildren = true;

    const name = child.nodeName;
    const value = xmlToJson(child);

    if (value === null || value === "") continue;

    if (obj[name]) {
      if (!Array.isArray(obj[name])) obj[name] = [obj[name]];
      obj[name].push(value);
    } else {
      obj[name] = value;
    }
  }

  if (!hasElementChildren) return null;
  return obj;
}
// ------------------------------------------------
// 3. Processa arquivo
// ------------------------------------------------
document.getElementById("file").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const text = await file.text();
  const xmlString = ofxToXml(text);

  const dom = new DOMParser().parseFromString(xmlString, "text/xml");

  // Se XML tem erro, mostrar no console para revisão
  if (dom.getElementsByTagName("parsererror").length > 0) {
    document.getElementById("resultado").textContent =
      "⚠ OFX contém erros estruturais, revise o XML gerado.\n\n" + xmlString;
    return;
  }

  const json = xmlToJson(dom.documentElement);

  document.getElementById("resultado").textContent =
    JSON.stringify(json, null, 2);
});
</script>

</body>
</html>
