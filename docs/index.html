<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jogo da Velha com Camadas</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: #111;
  }
  .layer {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    display: block;
  }
</style>
</head>
<body>
<canvas id="canvasBoard" class="layer"></canvas>
<canvas id="canvasAnim" class="layer"></canvas>

<script>
const boardCanvas = document.getElementById('canvasBoard');
const animCanvas = document.getElementById('canvasAnim');
const boardCtx = boardCanvas.getContext('2d');
const animCtx = animCanvas.getContext('2d');

let board, currentPlayer, gameOver;
let size, offsetX, offsetY, cellSize;

function resetGame() {
  board = Array(3).fill(null).map(() => Array(3).fill(null));
  currentPlayer = 'X';
  gameOver = false;
  animCtx.clearRect(0, 0, animCanvas.width, animCanvas.height);
  drawBoard();
}

function resizeCanvas() {
  boardCanvas.width = animCanvas.width = window.innerWidth;
  boardCanvas.height = animCanvas.height = window.innerHeight;

  const side = Math.min(window.innerWidth, window.innerHeight) * 0.8;
  size = side;
  offsetX = (window.innerWidth - side) / 2;
  offsetY = (window.innerHeight - side) / 2;
  cellSize = side / 3;

  drawBoard();
}
window.addEventListener('resize', resizeCanvas);

function drawBoard() {
  boardCtx.clearRect(0, 0, boardCanvas.width, boardCanvas.height);
  boardCtx.lineWidth = 8;
  boardCtx.strokeStyle = '#888';

  for (let i = 1; i <= 2; i++) {
    boardCtx.beginPath();
    boardCtx.moveTo(offsetX + i * cellSize, offsetY);
    boardCtx.lineTo(offsetX + i * cellSize, offsetY + size);
    boardCtx.stroke();

    boardCtx.beginPath();
    boardCtx.moveTo(offsetX, offsetY + i * cellSize);
    boardCtx.lineTo(offsetX + size, offsetY + i * cellSize);
    boardCtx.stroke();
  }

  // redesenha jogadas (sem animação)
  animCtx.clearRect(0, 0, animCanvas.width, animCanvas.height);
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      if (board[r][c] === 'X') drawX(r, c, false);
      if (board[r][c] === 'O') drawO(r, c, false);
    }
  }
}

animCanvas.addEventListener('click', (e) => {
  if (gameOver) {
    resetGame();
    return;
  }

  const x = e.clientX - offsetX;
  const y = e.clientY - offsetY;
  if (x < 0 || y < 0 || x > size || y > size) return;

  const c = Math.floor(x / cellSize);
  const r = Math.floor(y / cellSize);
  if (board[r][c]) return;

  if (currentPlayer === 'X') {
    board[r][c] = 'X';
    drawX(r, c, true);
    if (checkWin('X')) return endGame('X');
    currentPlayer = 'O';
  } else {
    board[r][c] = 'O';
    drawO(r, c, true);
    if (checkWin('O')) return endGame('O');
    currentPlayer = 'X';
  }

  if (board.flat().every(cell => cell)) endGame(null);
});

function drawX(row, col, animate = true) {
  const x0 = offsetX + col * cellSize;
  const y0 = offsetY + row * cellSize;
  const pad = cellSize * 0.2;

  const line1 = { x1: x0 + pad, y1: y0 + pad, x2: x0 + cellSize - pad, y2: y0 + cellSize - pad };
  const line2 = { x1: x0 + cellSize - pad, y1: y0 + pad, x2: x0 + pad, y2: y0 + cellSize - pad };

  animCtx.lineWidth = 10;
  animCtx.strokeStyle = '#00ffff';
  animCtx.lineCap = 'round';

  if (!animate) {
    animCtx.beginPath();
    animCtx.moveTo(line1.x1, line1.y1);
    animCtx.lineTo(line1.x2, line1.y2);
    animCtx.moveTo(line2.x1, line2.y1);
    animCtx.lineTo(line2.x2, line2.y2);
    animCtx.stroke();
    return;
  }

  const duration = 400;
  let start = null;

  function step(time) {
    if (!start) start = time;
    const elapsed = time - start;
    const progress = Math.min(elapsed / duration, 1);

    animCtx.clearRect(x0, y0, cellSize, cellSize);
    animCtx.beginPath();
    animCtx.moveTo(line1.x1, line1.y1);
    animCtx.lineTo(line1.x1 + (line1.x2 - line1.x1) * progress, line1.y1 + (line1.y2 - line1.y1) * progress);
    animCtx.stroke();

    if (elapsed > duration / 2) {
      const p2 = Math.min((elapsed - duration / 2) / duration, 1);
      animCtx.beginPath();
      animCtx.moveTo(line2.x1, line2.y1);
      animCtx.lineTo(line2.x1 + (line2.x2 - line2.x1) * p2, line2.y1 + (line2.y2 - line2.y1) * p2);
      animCtx.stroke();
    }

    if (elapsed < duration * 1.5) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

function drawO(row, col, animate = true) {
  const cx = offsetX + col * cellSize + cellSize / 2;
  const cy = offsetY + row * cellSize + cellSize / 2;
  const radius = cellSize * 0.3;

  animCtx.lineWidth = 10;
  animCtx.strokeStyle = '#ff4081';

  if (!animate) {
    animCtx.beginPath();
    animCtx.arc(cx, cy, radius, 0, 2 * Math.PI);
    animCtx.stroke();
    return;
  }

  const duration = 600;
  let start = null;

  function step(time) {
    if (!start) start = time;
    const elapsed = time - start;
    const progress = Math.min(elapsed / duration, 1);

    animCtx.clearRect(cx - radius - 10, cy - radius - 10, radius * 2 + 20, radius * 2 + 20);
    animCtx.beginPath();
    animCtx.arc(cx, cy, radius, 0, progress * 2 * Math.PI);
    animCtx.stroke();

    if (progress < 1) requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
}

function checkWin(p) {
  const lines = [
    [[0,0],[0,1],[0,2]],
    [[1,0],[1,1],[1,2]],
    [[2,0],[2,1],[2,2]],
    [[0,0],[1,0],[2,0]],
    [[0,1],[1,1],[2,1]],
    [[0,2],[1,2],[2,2]],
    [[0,0],[1,1],[2,2]],
    [[0,2],[1,1],[2,0]],
  ];
  for (const line of lines) {
    const [a,b,c] = line;
    if (board[a[0]][a[1]] === p && board[b[0]][b[1]] === p && board[c[0]][c[1]] === p) {
      drawWinLine(a, c);
      return true;
    }
  }
  return false;
}

function drawWinLine(a, c) {
  const pad = cellSize / 2;
  const x1 = offsetX + a[1] * cellSize + pad;
  const y1 = offsetY + a[0] * cellSize + pad;
  const x2 = offsetX + c[1] * cellSize + pad;
  const y2 = offsetY + c[0] * cellSize + pad;

  let progress = 0;
  animCtx.strokeStyle = '#00ff00';
  animCtx.lineWidth = 12;
  animCtx.lineCap = 'round';

  function animate() {
    animCtx.beginPath();
    animCtx.moveTo(x1, y1);
    animCtx.lineTo(x1 + (x2 - x1) * progress, y1 + (y2 - y1) * progress);
    animCtx.stroke();
    progress += 0.05;
    if (progress <= 1) requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);
}

function endGame(winner) {
  gameOver = true;
  setTimeout(() => {
    animCtx.font = `${cellSize * 0.5}px Arial`;
    animCtx.fillStyle = '#fff';
    animCtx.textAlign = 'center';
    animCtx.textBaseline = 'middle';
    const msg = winner ? `${winner} venceu!` : 'Empate!';
    animCtx.fillText(msg, window.innerWidth / 2, offsetY / 2);
    animCtx.font = `${cellSize * 0.25}px Arial`;
    animCtx.fillText('Clique para reiniciar', window.innerWidth / 2, offsetY / 2 + cellSize * 0.4);
  }, 400);
}

// Inicializa
resetGame();
resizeCanvas();
</script>
</body>
</html>
